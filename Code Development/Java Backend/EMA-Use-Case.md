**NOTE: If you are not familar with the scheduling functionality of Quartz and the `java.util.Timer` class, please read the documentation under (Scheduling-and-Quartz.md)[**

#EMA Use Case

Our main use for the scheduling functionality is in the EMA use case of FormBuilder. This use case requires us to be able to dynamically schedule events that will alert participants in a study that they must fill out a form in the application and also make this form available to the user. The key aspect of this use case is that it must be dynamic, meaning a user needs to be able to input when these users will receive emails and when the form should be activated. To accomplish this, we have created a POJO class called `dash.pojo.Study`. This class is the abstraction of the scheduling problem presented by the use case. It includes data about when the study needs to be executed, usernames of participants in the studies, and the form associated with the study. Through the front end, a user may define all the information which is then stored as an study object in the application. Also, a `Map<Long, Long> activeStudies` member variable is included in the `User` class. This member variable represents a list of studyIds and formIds that are currently "active" for that particular user. In the context of this use case, an "activeStudy" is a study that is attached to a form the user is expected to currently reply to. The form associated with the study could also be considered "active" for the user. This map is used in the EMA FormViewer application to request and render the proper forms when the user logs in. 

The approach used to accomplish this scheduling utilizes both the `java.Util.Timer` class and the Quartz Scheduling Library. The proper Resource, Service and DAO layers have been created for the `Study` POJO. Through user input, a study is created that includes the specific timing information for that study, including a field called `startDate`. This field represents the first day the study will take place. The study class also includes a function `public List<String> generateCronStrings()` which generates a list of cron strings that can be used to create `CronTriggers` for the study. This method generates multiple cron strings if multiple times for execution are present. This is simpler than trying to generate one string to cover all needs. For example, if a study was supposed to go out at 8:00am every day and also 12:30pm every day, a cron string cannot be generated. For example, if you tried to use this string, `* 0,30 8,12 * * * `, the trigger would actually fire four times, at 8:00am, 8:30am, 12:00pm, and 12:30pm. Instead, we create two triggers, `* 0 8 * * *` and `* 30 12 * * *`.

##Scheduling Jobs
An important part of our mechanism for scheduling is the `QuartzInitServletContextListener` class. This class implements the `ServletContextListener` interface, which includes two methods, `public void contextInitialized(ServletContextEvent sce)` and `public void contextDestroyed(ServletContextEvent sce)`. Without going into further detail, the `contextInitialized()` method is called when the servlet is initialized. This occurs when a new WAR is deployed, the server is restarted, or anything else that would cause the program to start up from scratch occurs. In this method, we initialize a timer and use it to schedule an instance of the `DailyInitTask` to be executed daily at night. We use a timer because we do not want it to be persistent. If the memory is cleared for some reason and the timer is lost, it will be recreated whenever the application is started again. If this event was persistent, we would need to stop it from rescheduling itself in the event of the application stopping. This is needlessly complicated, so instead we just use the non-persistent timer. The `run()` function of this class queries the database to retrieve all studies with start dates on the following day (for example on 1/11/2016, it will look for all studies with a start date of 1/12/2016). It then iterates through this list and creates an instance of the `StudyJob` class for each study. This class extends the `QuartzJobBean` class which is provided by Spring. This abstract class implements the `Job` interface. We extend this class instead of directly implementing the `Job` interface because it allows the class to work with the Spring Framework better. The `public void executeInternal(JobExecutionContext arg0)` method is equivalent to the `public void execute()` method from the `Job` interface. For each study, an instance of the `StudyJob` class is created with the data taken from the study. This data includes the formId, studyId, and a `Set<String> participants` member variable that holds the usernames of all the users who are participants in this study. Then, the `generateCronStrings()` method is called for that study. Each element of the returned `List<String>` is used to create an instance of `CronTrigger` using that cron string. These instances are stored in a `List<Trigger>`. Each job is then mapped to it's respective `List<String>` through a mapping, `Map<JobDetail, List<Trigger>> jobs`. This once every study retrieved by the query has been used to generate a job and appropriate triggers, the triggers are attached to their jobs by passing the `jobs` map to the Quartz Scheduler using the `scheduleJobs(Map<JobDetail, List<Trigger>> arg0, boolean arg1)` method.At the time of execution, an alert will be sent via text or email to the participants in the list, and the study will be "Activated" for those users by adding the job's studyId and formId to each user's `activeStudies` map. When a user replies to the form through the FormViewer application, it removes that studyId: formId pair from the activeStudies mapping of the user and thus "de-activating" the study.

##Timing Out
An extra functionality added to this use case is the ability activate a study for a specific duration rather then allowing a user to reply to it indefinitely. The idea is that if a user does not reply to a form within a set amount of time, that form becomes unavailable to them again. To accomplish this, we added to the `StudyJob` class and utilize another timer. When a study is activated in a `StudyJob`, the duration variable is added to the current hours to calculate what time this study should become inactive again. This datetime is then written to the database under the **expiration_times** table, along with the study ID. Again, we initialize a timer in the `QuartzInitServletContextListener`. This timer schedules an instance of the `TimeTask` class to execute every 5 minutes, starting in 5 minutes. We use a timer rather than a job for the same reasons as above. A persistent job in the `QuartzInitServletContextListener` would consistently reschedule on top of itself. We schedule it to run after 5 minutes rather than immediately to prevent an error from occurring. In the `run()` method of this class, the current Spring Context must be acquired to retrieve the Service and Dao layer beans. If the task were to run immediately, the server may not be fully finished starting up before the method attempts to acquire the Spring Context, and this throws an exception. To avoid this, we simply delay the execution of the task to insure the server has fully started. The actual functionality of the `run()` method queries the database to retrieve all the studies from the **expiration_times** table that are paired with a date before now. These studyId's are then removed from the **active_studies** table, and this removing them from the `activeStudies` map of the user. The studies are now "deactivated" for all users. 